import { app, BrowserWindow, ipcMain, shell, safeStorage } from 'electron';
import * as fs from 'fs';
import * as path from 'path';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Store mapping of chat windows
const chatWindows = new Map<string, BrowserWindow>();

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 700,
    width: 250,
    frame: false,
    transparent: true,
    roundedCorners: false,
    acceptFirstMouse: true,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  
  // Set the main window title
  mainWindow.setTitle('Mark Instant Messenger');

  // Open the DevTools.
  // mainWindow.webContents.openDevTools();

  // Handle window.open() for child windows
  mainWindow.webContents.setWindowOpenHandler(({ url, features }) => {
    console.log('Main process: window.open() called');
    console.log('URL:', url);
    console.log('Features:', features);
    
    // Handle external URLs
    if (url.startsWith('http') && url !== 'about:blank') {
      console.log('Opening external URL:', url);
      shell.openExternal(url);
      return { action: 'deny' };
    }

    // Parse window features
    const width = parseInt(features.match(/width=(\d+)/)?.[1] || '400', 10);
    const height = parseInt(features.match(/height=(\d+)/)?.[1] || '500', 10);
    
    console.log('Creating new window with dimensions:', width, 'x', height);

    return {
      action: 'allow',
      overrideBrowserWindowOptions: {
        width,
        height,
        frame: false,
        transparent: false, // Temporarily disabled for debugging
        backgroundColor: '#ffffff',
        roundedCorners: false,
        minHeight: 300,
        minWidth: 300,
        acceptFirstMouse: true,
        webPreferences: {
          preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
          contextIsolation: true,
          nodeIntegration: false
        }
      }
    };
  });

  // Add handler for new windows created
  mainWindow.webContents.on('did-create-window', (childWindow, details) => {
    console.log('Created new window:', details.frameName);
    childWindow.show();
    childWindow.focus();
    
    // Set the window title based on the window name
    if (details.frameName && details.frameName.startsWith('Instant Message with')) {
      childWindow.setTitle(details.frameName);
      console.log('Set window title to:', details.frameName);
      // Store the window reference
      chatWindows.set(details.frameName, childWindow);
      
      // Clean up when window is closed
      childWindow.on('closed', () => {
        chatWindows.delete(details.frameName);
      });
    }
    
    // Log window count
    console.log('Total windows:', BrowserWindow.getAllWindows().length);
  });

  // Handle window control IPC messages
  ipcMain.on('window-minimize', (event) => {
    // Get the window that sent this event
    const window = BrowserWindow.fromWebContents(event.sender);
    console.log('Minimize request from window:', window?.getTitle());
    if (window) {
      window.minimize();
    }
  });

  ipcMain.on('window-maximize', (event) => {
    const window = BrowserWindow.fromWebContents(event.sender);
    if (window) {
      if (window.isMaximized()) {
        window.restore();
      } else {
        window.maximize();
      }
    }
  });

  ipcMain.on('window-close', (event) => {
    const window = BrowserWindow.fromWebContents(event.sender);
    console.log('Close request from window:', window?.getTitle());
    if (window) {
      window.close();
    }
  });
  
  // Handle focusing child windows
  ipcMain.on('focus-window', (event, windowName) => {
    console.log('Focusing window with name:', windowName);
    const targetWindow = chatWindows.get(windowName);
    if (targetWindow && !targetWindow.isDestroyed()) {
      targetWindow.focus();
      targetWindow.show();
    }
  });
  
  // Handle setting window title
  ipcMain.on('set-window-title', (event, title) => {
    const window = BrowserWindow.fromWebContents(event.sender);
    if (window) {
      window.setTitle(title);
    }
  });
  
  // Handle minimizing window by title
  ipcMain.on('minimize-window-by-title', (event, title) => {
    console.log('Minimize window by title:', title);
    console.log('Available windows:', Array.from(chatWindows.keys()));
    const targetWindow = chatWindows.get(title);
    if (targetWindow && !targetWindow.isDestroyed()) {
      console.log('Minimizing window');
      targetWindow.minimize();
    } else {
      console.log('Window not found or destroyed');
    }
  });
  
  // Handle API key storage
  ipcMain.handle('store-api-key', async (event, apiKey: string) => {
    if (!safeStorage.isEncryptionAvailable()) {
      throw new Error('Encryption not available');
    }
    const encrypted = safeStorage.encryptString(apiKey);
    // Store in app's user data
    const userDataPath = app.getPath('userData');
    const keyPath = path.join(userDataPath, 'anthropic-key');
    fs.writeFileSync(keyPath, encrypted);
    return true;
  });
  
  ipcMain.handle('get-api-key', async () => {
    try {
      const userDataPath = app.getPath('userData');
      const keyPath = path.join(userDataPath, 'anthropic-key');
      
      if (!fs.existsSync(keyPath)) {
        return null;
      }
      
      const encrypted = fs.readFileSync(keyPath);
      if (!safeStorage.isEncryptionAvailable()) {
        throw new Error('Encryption not available');
      }
      return safeStorage.decryptString(encrypted);
    } catch (error) {
      console.error('Error retrieving API key:', error);
      return null;
    }
  });
  
  ipcMain.handle('clear-api-key', async () => {
    try {
      const userDataPath = app.getPath('userData');
      const keyPath = path.join(userDataPath, 'anthropic-key');
      
      if (fs.existsSync(keyPath)) {
        fs.unlinkSync(keyPath);
      }
      return true;
    } catch (error) {
      console.error('Error clearing API key:', error);
      return false;
    }
  });
  
  // Handle closing window by title
  ipcMain.on('close-window-by-title', (event, title) => {
    console.log('Close window by title:', title);
    const targetWindow = chatWindows.get(title);
    if (targetWindow && !targetWindow.isDestroyed()) {
      console.log('Closing window');
      targetWindow.close();
    }
  });
  
  // Handle Claude API calls from main process
  ipcMain.handle('send-claude-message', async (event, message: string, conversationHistory: any[]) => {
    try {
      // Get the API key properly
      const userDataPath = app.getPath('userData');
      const keyPath = path.join(userDataPath, 'anthropic-key');
      
      if (!fs.existsSync(keyPath)) {
        throw new Error('API key not set');
      }
      
      const encrypted = fs.readFileSync(keyPath);
      if (!safeStorage.isEncryptionAvailable()) {
        throw new Error('Encryption not available');
      }
      const apiKey = safeStorage.decryptString(encrypted);
      
      if (!apiKey) {
        throw new Error('API key not set');
      }
      
      // Import Anthropic SDK dynamically to avoid issues
      const { default: Anthropic } = await import('@anthropic-ai/sdk');
      const anthropic = new Anthropic({ apiKey });
      
      console.log('Sending message to Claude API from main process...');
      const response = await anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1024,
        messages: [
          ...conversationHistory,
          { role: 'user', content: message }
        ],
        system: "You are Claude, chatting in an AOL Instant Messenger style chat. Keep your responses conversational, friendly, and relatively brief (a few sentences at most). Use casual internet chat style when appropriate."
      });
      
      console.log('Got response from Claude:', response);
      
      if (response.content[0].type === 'text') {
        return response.content[0].text;
      }
      
      return 'Sorry, I couldn\'t process that response.';
    } catch (error) {
      console.error('Error calling Claude API from main:', error);
      if (error instanceof Error && error.message?.includes('401')) {
        throw new Error('Invalid API key');
      }
      throw new Error('Failed to send message to Claude');
    }
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
